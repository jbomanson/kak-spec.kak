#! /usr/bin/env -S ruby --disable=gems

require "shellwords"

STARTUP_MONOTONIC_TIME = Process.clock_gettime(Process::CLOCK_MONOTONIC)

DEBUG_EXPECTED_CONTENT = <<EOF
*** This is the debug buffer, where debug info will be written ***

EOF

LINE_NUMBER_COLOR    = :light_blue
NEWLINE_MARKER_COLOR = :light_blue

# Returns a path to the kak-spec program.
def kak_spec_program
  $kak_spec_program ||= ENV["KAK_SPEC_PROGRAM"]
end

def newline_marker
  $newline_marker ||= Terminal.in_color("Â¬", NEWLINE_MARKER_COLOR)
end

TEST_CASE_KAKOUNE_COMMAND_NAME = "spec-assert"

class TranslationException < StandardError
end

module Terminal
  extend self

  # Wraps a string with terminal color codes.
  def in_color(text, color)
    # TODO: Disable if the output is not a terminal.
    # Source of color codes:
    # https://misc.flogisoft.com/bash/tip_colors_and_formatting
    code =
      case color
      when :red                      then 31
      when :green                    then 32
      when :yellow                   then 33
      when :blue                     then 34
      when :magenta                  then 35
      when :cyan                     then 36
      when :light_gray               then 37
      when :dark_gray                then 90
      when :light_red                then 91
      when :light_green              then 92
      when :light_yellow             then 93
      when :light_blue               then 94
      when :light_magenta            then 95
      when :light_cyan               then 96
      when :white                    then 97
      when :default_background       then 49
      when :black_background         then 40
      when :red_background           then 41
      when :green_background         then 42
      when :yellow_background        then 43
      when :blue_background          then 44
      when :magenta_background       then 45
      when :cyan_background          then 46
      when :light_gray_background    then 47
      when :dark_gray_background     then 100
      when :light_red_background     then 101
      when :light_green_background   then 102
      when :light_yellow_background  then 103
      when :light_blue_background    then 104
      when :light_magenta_background then 105
      when :light_cyan_background    then 106
      when :white_background         then 107
      else raise "Unrecognized color: #{color}"
      end
    "\e[#{code}m#{text}\e[0m"
  end

  # Highlight any trailing whitespace in given lines with terminal color codes.
  # @return [String]
  def any_trailing_whitespace_in_color(line)
    # Highlight trailing whitespace.
    line.gsub(/[[:blank:]]+$/) {|text| Terminal.in_color(text, :red_background)}
  end
end

def throw(*args)
  raise TranslationException.new(*args)
end

TestCase = Struct.new(:scope, :title, :input) do
  # Returns a shell command in the form of a string that reruns this specific
  # test case alone.
  # @return [String]
  def shell_command_details
    Terminal.in_color(
      [
        kak_spec_program,
        "-title",
        "^#{Regexp.escape(title)}$",
        scope.suite_file,
      ].shelljoin,
      :red,
    )
  end
end

# Mark all newlines with a visible character.
def mark_newlines_explicitly(string)
  string.gsub(/\n/, "#{newline_marker}\n")
end

def format_block(title, text)
  string = "\n"
  string << "    #{title}:\n"
  text.each_line.each_with_index do |line, index|
    string << Terminal.in_color("    %3i|" % (index + 1), LINE_NUMBER_COLOR)
    string << mark_newlines_explicitly(Terminal.any_trailing_whitespace_in_color(line))
    string << "\n" unless line.end_with?("\n")
  end
  string
end

# An object representing a comparisiong between an actual and expected value of a kakoune kakoune_expansion.
Comparison = Struct.new(:type, :kakoune_expansion, :expected_value, :actual_value) do
  # Parses expectation message components sent with spec-assert.
  def self.partition_and_create_from_arguments(array)
    comparisons = []
    remaining_arguments = array.clone
    until remaining_arguments.first == "END_OF_EXPECTATIONS"
      if remaining_arguments.empty?
        throw "Missing 'END_OF_EXPECTATIONS' from assertion message: #{array}"
      end
      num_members = self.members.size
      if remaining_arguments.size < num_members
        throw \
          "Expected a kakoune expansion in an assertion at the point between " +
          "#{array[0...comparisons.size * num_members]} and #{remaining_arguments}"
      end
      comparisons << self.new(*remaining_arguments.shift(num_members))
    end
    remaining_arguments.shift
    [comparisons, remaining_arguments]
  end

  # Formats details of this expectation to an {IO} -- {#pass?} ed or not.
  def format_details(io)
    if expected_value == actual_value
      if type == "comparison_explicit"
        io << format_block("Accepted #{kakoune_expansion}", actual_value)
      end
    else
      io << format_block("Expected #{kakoune_expansion}", expected_value)
      io << format_block("Actual #{kakoune_expansion}", actual_value)
    end
  end

  # Determines whether this expectation passed.
  def pass?
    expected_value == actual_value
  end
end

module Assertion
  # <context_file> <output> <error> <assertion> <arg>...
  def self.from_arguments(scope, array)
    comparisons, remaining_arguments = Comparison.partition_and_create_from_arguments(array)
    # Unpack the arguments.
    title, input, unused_command = remaining_arguments
    # Convert the arguments into higher level objects.
    Assertion::WithComparisons.new(
      TestCase.new(scope, title, input),
      comparisons,
    )
  end

  # Determines whether this assertion was satisfied.
  def pass?
    raise "NYI"
  end

  def progress_tick
    if pass?
      Terminal.in_color(".", :green)
    else
      Terminal.in_color("F", :red)
    end
  end

  # Assuming this assertion did not {#pass?}, returns a description of the relevant details.
  def failure_details(index)
    string = ""
    string << "  #{Terminal.in_color("#{index})", :red)} #{test_case.title}\n"
    string
  end
end

module Assertion
  # An assertion that is satisfied if a number of {Comparison} objects are satisfied.
  WithComparisons = Struct.new(:test_case, :comparisons) do
    include Assertion

    # Implements {Assertion#pass?}.
    def pass?
      if @pass.nil?
        @pass = comparisons.all?(&:pass?)
      end
      @pass
    end

    # Prints details of this assertion.
    def failure_details(index)
      string = ""
      string << super
      string << format_block("Input", test_case.input)
      comparisons.each do |expectation|
        expectation.format_details(string)
      end
      unless test_case.scope.debug.empty?
        string << format_block("Contents of *debug*", test_case.scope.debug)
      end
      string
    end
  end
end

# An error caught in kakoune code outside of assertions.
# These errors are reported separately from assertion failures.
NonAssertionError = Struct.new(:scope, :message) do
  def progress_tick
    Terminal.in_color("E", :red)
  end

  def non_assertion_error_details
    string = ""
    string << "  #{Terminal.in_color("?)", :red)} Error\n"
    scope.each_with_index do |context_scope, index|
      string << format_block(
        index == 0 ? "Suite" : "Context",
        context_scope.description,
      )
    end
    string << format_block("Message", message)
    unless scope.debug.empty?
      string << format_block("Contents of *debug*", scope.debug)
    end
    string
  end
end

class Presenter
  attr_reader :assertions
  attr_reader :non_assertion_errors

  def initialize
    @assertions = []
    @non_assertion_errors = []
  end

  def present_assertion(assertion)
    @assertions << assertion
    print assertion.progress_tick
  end

  def present_error(error)
    @non_assertion_errors << error
    print error.progress_tick
  end

  def failure_count
    @failure_count ||= assertions.count { |assertion| !assertion.pass? }
  end

  def pass?
    non_assertion_errors.empty? && failure_count == 0
  end

  def present_failed_example_details
    return if failure_count == 0
    puts
    puts "Failures:"
    assertions.each_with_index do |assertion, index|
      next if assertion.pass?
      puts
      puts assertion.failure_details(index + 1)
    end
  end

  # Summarises failed examples in a way that shows files and line numbers.
  def present_failed_example_summary
    return if failure_count == 0
    puts
    puts "Failed examples:"
    puts
    puts(
      assertions.reject(&:pass?).map do |assertion|
        assertion.test_case.shell_command_details
      end
    )
  end

  # Summarises failed examples in a way that shows files and line numbers.
  def present_non_assertion_error_summary
    return if non_assertion_errors.empty?
    puts
    puts "Errors other than assertion failures:"
    non_assertion_errors.each do |error|
      puts
      puts error.non_assertion_error_details
    end
  end

  def present_summary_briefly
    elapsed_time =
      Process.clock_gettime(Process::CLOCK_MONOTONIC) - STARTUP_MONOTONIC_TIME
    puts "Finished in %0.2f milliseconds" % (elapsed_time * 1000.0)
    puts Terminal.in_color(
      "#{assertions.size} examples, " +
      "#{failure_count} failures, " +
      "#{non_assertion_errors.size} errors",
      pass? ? :green : :red
    )
  end

  def present_summary
    puts
    present_failed_example_details
    puts unless pass?
    present_summary_briefly
    present_failed_example_summary
    present_non_assertion_error_summary
  end
end

def stubbornly
  begin
    yield
  rescue TranslationException => e
    puts
    puts e
  rescue StandardError => e
    puts
    puts "Caught unexpected Ruby exception: #{e}"
    puts e.backtrace
    puts
  end
end

# A wrapper over an IO for reading messages sent with the kakoune command `spec-send`.
class MessageReader
  # An implementation detail of {MessageReader}.
  # A temporarily stored message together with some metadata.
  Message = Struct.new(:size_in_lines, :number, :payload_arguments)

  def initialize(io)
    # An IO object that will be set to nil after the first time it returns nil.
    @io = io
    # A generally monotonically increasing message number.
    # Unless something goes wrong or there are no more messages, the next {#read_message} call
    # will return a message with this number.
    @next_expected_number = 0
    # A temporary collection of messages read from io but not yet by the user.
    @unread_messages = []
  end

  # Reads the next message as an array of strings.
  # The order in which messages are read is exactly the same as in which they are sent via the
  # kakoune command `spec-send`.
  # Returns nil once there are no more messages.
  # @return [Array<String>, nil]
  def read_message
    loop do
      if index = @unread_messages.find_index {|message| message.number == @next_expected_number}
        # Use a previously read message.
        @next_expected_number += 1
        break @unread_messages.delete_at(index).payload_arguments
      elsif header_line = @io && @io.gets || (@io = nil)
        # Receive a new message.
        size_in_lines = header_line.to_i
        size_in_lines == 0 and throw "Expected <size_in_lines>, got '#{header_line}'"
        number_s, *payload_arguments = @io.take(size_in_lines).join.shellsplit
        @unread_messages << Message.new(size_in_lines, number_s.to_i, payload_arguments)
      elsif @unread_messages.empty?
        # There are no more messages.
        break
      else
        # There are unread messages with unexpected message numbers.
        next_available_number = @unread_messages.min_by(&:number)
        STDERR.puts "kak-spec: reporter: warning: " +
          "expected message number #{@next_expected_number}, " +
          "settling for #{next_available_number}"
        # Tolerate this situation by pretending to expect the next available message.
        @next_expected_number = next_available_number
      end
    end
  end

  # Yields all remaining messages one by one.
  # @yieldparam [Array<String>]
  def each
    while message = read_message
      yield message
    end
  end

  # Returns an {Enumerable} consisting of all messages until target_message.
  # Using the enumerable will advance this {MessageReader} until and over the target message.
  def until_message(target_message_task)
    UntilMessage.new(self, target_message_task)
  end

  # This is an implementation detail of {MessageReader#until_message}.
  class UntilMessage
    include Enumerable

    attr_reader :target_message

    def initialize(reader, target_message_task)
      @reader = reader
      @target_message_task = target_message_task
    end

    def each
      @reader.each do |message|
        if message.first == @target_message_task
          @target_message = message
          break
        else
          yield message
        end
      end
    end
  end
end

Scope = Struct.new(:parent, :description, :debug_line_begin) do
  include Enumerable

  attr_accessor :debug
  attr_accessor :debug_line_end

  def self.top_level
    @top_level ||= Scope.new(nil, "Top Level", 0)
  end

  def each
    return unless parent
    parent.each {|parent_scope| yield parent_scope}
    yield self
  end

  def suite_file
    first.description
  end
end

# Parses a debug line number sent as part of scope messages into an integer.
def parse_debug_line_number(number_as_string)
  # Deduct 1 because kakoune always maintains an extra empty line at the end of the debug buffer.
  number_as_string.to_i - 1
end

# Reads commands from a fifo until the "quit" command arrives.
# The commands can consist of one or more lines.
# The first line must indicate the type of the command.
def main(fifo)
  unless File.exist?(fifo)
    puts "Usage: reporter <fifo>"
    puts "Error: file does not exist: \"#{fifo}\""
    exit
  end

  presenter = Presenter.new
  File.open(fifo, "r") do |io|
    message_reader = MessageReader.new(io)
    task, session, client = message_reader.read_message
    unless task == "message_init" && session && client
      throw "Expected message_init <session> <client>, received: #{([task] + arguments).shelljoin}"
    end
    scope_stack = [Scope.top_level]
    scope_universe = []
    until_reader = message_reader.until_message("message_quit")
    until_reader.to_a.each do |message_components|
      stubbornly do
        task, *arguments = message_components
        case task.chomp
        when "message_assert"
          presenter.present_assertion(Assertion.from_arguments(scope_stack.last, arguments))
        when "message_non_assertion_error"
          presenter.present_error(NonAssertionError.new(scope_stack.last, arguments.join(" ")))
        when "message_scope_begin"
          description, debug_line_begin = arguments
          scope_stack << Scope.new(scope_stack.last, description, parse_debug_line_number(debug_line_begin))
          scope_universe << scope_stack.last
        when "message_scope_end"
          description, debug_line_end = arguments
          if scope_stack.last.description == description
            scope_stack.pop.debug_line_end = parse_debug_line_number(debug_line_end)
          else
            throw \
              "Expected end of scope #{scope_stack.last}, " +
              "got end of scope #{description}"
          end
        else
          throw "Unexpected task: #{([task] + arguments).shelljoin}"
        end
      end
    end
    # Attribute debug information to the appropriate scopes.
    debug_buffer_lines = until_reader.target_message.last.each_line.to_a
    scope_universe.reverse_each do |scope|
      lines = debug_buffer_lines[scope.debug_line_begin...scope.debug_line_end]
      scope.debug = lines.join
      lines.each(&:clear)
    end
    # Present a summary of assertions.
    presenter.present_summary
    # Print any unaccounted debug values.
    unless (stray_debug_message = debug_buffer_lines.join) == DEBUG_EXPECTED_CONTENT
      puts
      puts "P.S.:"
      puts format_block(
        "Contents of *debug* that did not fall into any file, context, or test",
        stray_debug_message,
      )
    end
    system("echo 'evaluate-commands -client #{client} %(spec-quit-end)' | kak -p #{session}")
  end
end

begin
  main(ARGV.shift)
rescue => e
  puts e.to_s
  puts e.backtrace
end
