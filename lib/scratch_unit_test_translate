#! /usr/bin/env -S ruby --disable=gems

require "shellwords"

STARTUP_MONOTONIC_TIME = Process.clock_gettime(Process::CLOCK_MONOTONIC)

class TranslationException < StandardError
end

module Terminal
  extend self

  # Wraps a string with terminal color codes.
  def in_color(text, color)
    # TODO: Disable if the output is not a terminal.
    # Source of color codes:
    # https://misc.flogisoft.com/bash/tip_colors_and_formatting
    code =
      case color
      when :red                      then 31
      when :green                    then 32
      when :yellow                   then 33
      when :blue                     then 34
      when :magenta                  then 35
      when :cyan                     then 36
      when :light_gray               then 37
      when :dark_gray                then 90
      when :light_red                then 91
      when :light_green              then 92
      when :light_yellow             then 93
      when :light_blue               then 94
      when :light_magenta            then 95
      when :light_cyan               then 96
      when :white                    then 97
      when :default_background       then 49
      when :black_background         then 40
      when :red_background           then 41
      when :green_background         then 42
      when :yellow_background        then 43
      when :blue_background          then 44
      when :magenta_background       then 45
      when :cyan_background          then 46
      when :light_gray_background    then 47
      when :dark_gray_background     then 100
      when :light_red_background     then 101
      when :light_green_background   then 102
      when :light_yellow_background  then 103
      when :light_blue_background    then 104
      when :light_magenta_background then 105
      when :light_cyan_background    then 106
      when :white_background         then 107
      else raise "Unrecognized color: #{color}"
      end
    "\e[#{code}m#{text}\e[0m"
  end

  # Highlight any trailing whitespace in given lines with terminal color codes.
  # @return [String]
  def any_trailing_whitespace_in_color(line)
    # Highlight trailing whitespace.
    line.gsub(/\s+$/) {|text| Terminal.in_color(text, :red_background)} +
      if line.end_with?("\n")
        ""
      else
        "\n"
      end
  end
end

def throw(*args)
  raise TranslationException.new(*args)
end

# A convenience class representing a file with a {#filename} and lazily read {#lines}.
FileWithLines = Struct.new(:filename) do
  # An array of lines generally ending in newlines read from {#filename}.
  # @return [Array<String>] Lines read from {#filename}.
  def lines
    @lines ||= File.readlines(filename)
  end
end

TestCase = Struct.new(:file_with_lines, :context, :kakoune_command_name, :output, :error, :title, :input) do
  def brief
    context.empty? ? title : "#{context} #{title}"
  end

  # A regular expression that approximates how the original kakoune command call
  # that created this test case probably looks like.
  # @return [Regexp]
  def kakoune_call_regex
    @kakoune_call_regex ||=
      begin
        title_regex = Regexp.escape(title)
        /#{kakoune_command_name}\s+(#{title_regex}\b|"#{title_regex}"|'#{title_regex}')/
      end
  end

  # Returns a shell command line that can be ran to rerun this specific test case alone.
  # @return [String]
  def shell_command_details
    line_index = file_with_lines.lines.index {|line| line =~ kakoune_call_regex}
    line_detail = line_index ? ":#{line_index + 1}" : ""
    Terminal.in_color("some dummy command #{file_with_lines.filename}#{line_detail}", :red) +
      Terminal.in_color(" # #{title}", :light_blue)
  end
end

def format_block(title, text, check_end = false)
  string = "\n"
  string << "    #{title}:\n"
  text.each_line.each_with_index do |line, index|
    string << Terminal.in_color("    %3i|" % (index + 1), :light_blue)
    string << Terminal.any_trailing_whitespace_in_color(line)
  end
  if check_end && !text.end_with?("\n")
    string << "    %3s " % ""
    string << "(no trailing newline)\n"
  end
  string
end

module Assertion
  # <context_file> <output> <error> <assertion> <arg>...
  def self.from_arguments(array)
    # Unpack the arguments.
    file,
      context,
      kakoune_command_name,
      output,
      error,
      title,
      input,
      matcher,
      expected_value,
      *command =
        array
    # Convert the argumens into higher level objects.
    file_with_lines = FileWithLines.new(file)
    case matcher
    when "output" then Assertion::Output
    when "error"  then Assertion::Error
    else throw "Unexpected assertion type: '#{matcher}'"
    end.new(
      TestCase.new(
        file_with_lines,
        context,
        kakoune_command_name,
        output,
        error,
        title,
        input,
      ),
      expected_value,
    )
  end

  # Determines whether this assertion was satisfied.
  def pass?
    raise "NYI"
  end

  def progress_tick
    if pass?
      Terminal.in_color(".", :green)
    else
      Terminal.in_color("F", :red)
    end
  end

  # Assuming this assertion did not {#pass?}, returns a description of the relevant details.
  def failure_details(index)
    string = ""
    string << "  #{Terminal.in_color("#{index})", :red)} #{test_case.title}\n"
    string
  end
end

module Assertion
  Output = Struct.new(:test_case, :expected_output) do
    include Assertion

    # Implements {Assertion#pass?}.
    def pass?
      if @pass.nil?
        @pass = test_case.error.empty? &&
          test_case.output == expected_output
      end
      @pass
    end

    def failure_details(index)
      check_end =
        [test_case.input, expected_output, test_case.output].select do |text|
          !text.empty?
        end.map do |text|
          text.end_with?("\n")
        end.uniq.size != 1
      string = ""
      string << super
      string << format_block("Input", test_case.input, check_end)
      if expected_output != test_case.output
        string << format_block("Expected output", expected_output, check_end)
        string << format_block("Actual output", test_case.output, check_end)
      end
      unless test_case.error.empty?
        string << format_block("Unexpected error", test_case.error)
      end
      string
    end
  end
end

module Assertion
  # An assertion that matches a kakoune error message against a regular expression.
  Error = Struct.new(:test_case, :expected_error_regex) do
    include Assertion

    # Implements {Assertion#pass?}.
    def pass?
      if @pass.nil?
        @pass =
          (
            !test_case.error.empty? &&
              test_case.error =~ /#{expected_error_regex}/
          ) ? true : false
      end
      @pass
    end

    def failure_details(index)
      string = ""
      string << super
      string << format_block("Input", test_case.input)
      string << format_block("Output", test_case.output)
      string << format_block("Expected error regex", expected_error_regex)
      string << format_block("Actual error", test_case.error)
      string
    end
  end
end

NonAssertionError = Struct.new(:suite, :context, :message) do
  def progress_tick
    Terminal.in_color("E", :red)
  end

  def non_assertion_error_details
    string = ""
    string << "  #{Terminal.in_color("?)", :red)} Error\n"
    string << format_block("Suite", suite) if suite
    string << format_block("Context", context) if context
    string << format_block("Message", message)
    string
  end
end

class Presenter
  attr_reader :assertions
  attr_reader :non_assertion_errors

  def initialize
    @assertions = []
    @non_assertion_errors = []
  end

  def present_assertion(assertion)
    @assertions << assertion
    print assertion.progress_tick
  end

  def present_error(error)
    @non_assertion_errors << error
    print error.progress_tick
  end

  def failure_count
    @failure_count ||= assertions.count { |assertion| !assertion.pass? }
  end

  def pass?
    non_assertion_errors.empty? && failure_count == 0
  end

  def present_failed_example_details
    return if failure_count == 0
    puts
    puts "Failures:"
    assertions.each_with_index do |assertion, index|
      next if assertion.pass?
      puts
      puts assertion.failure_details(index + 1)
    end
  end

  # Summarises failed examples in a way that shows files and line numbers.
  def present_failed_example_summary
    return if failure_count == 0
    puts
    puts "Failed examples:"
    puts
    puts(
      assertions.reject(&:pass?).map do |assertion|
        assertion.test_case.shell_command_details
      end
    )
  end

  # Summarises failed examples in a way that shows files and line numbers.
  def present_non_assertion_error_summary
    return if non_assertion_errors.empty?
    puts
    puts "Errors other than assertion failures:"
    puts
    puts(
      non_assertion_errors.map do |error|
        error.non_assertion_error_details
      end
    )
  end

  def present_summary_briefly
    elapsed_time =
      Process.clock_gettime(Process::CLOCK_MONOTONIC) - STARTUP_MONOTONIC_TIME
    puts "Finished in %0.2f milliseconds" % (elapsed_time * 1000.0)
    puts Terminal.in_color(
      "#{assertions.size} examples, " +
      "#{failure_count} failures, " +
      "#{non_assertion_errors.size} errors",
      pass? ? :green : :red
    )
  end

  def present_summary
    puts
    present_failed_example_details
    puts unless pass?
    present_summary_briefly
    present_failed_example_summary
    present_non_assertion_error_summary
  end
end

def stubbornly
  begin
    yield
  rescue TranslationException => e
    puts
    puts e
  rescue StandardError => e
    puts
    puts "Caught unexpected Ruby exception: #{e}"
    puts e.backtrace
    puts
  end
end

class MessageReader
  Message = Struct.new(:size_in_lines, :number, :payload_arguments)

  def initialize(io)
    # An IO object that will be set to nil after the first time it returns nil.
    @io = io
    # A generally monotonically increasing message number.
    # Unless something goes wrong or there are no more messages, the next {#read_message} call
    # will return a message with this number.
    @next_expected_number = 0
    # A temporary collection of messages read from io but not yet by the user.
    @unread_messages = []
  end

  # Reads the next message in line as an array of strings.
  # Returns nil once there are no more messages.
  # @returns [Array<String>, nil]
  def read_message
    loop do
      if index = @unread_messages.find_index {|message| message.number == @next_expected_number}
        # Use a previously read message.
        @next_expected_number += 1
        break @unread_messages.delete_at(index).payload_arguments
      elsif header_line = @io && @io.gets || (@io = nil)
        # Receive a new message.
        size_in_lines = header_line.to_i
        size_in_lines == 0 and throw "Expected <size_in_lines>, got '#{header_line}'"
        number_s, *payload_arguments = @io.take(size_in_lines).join.shellsplit
        @unread_messages << Message.new(size_in_lines, number_s.to_i, payload_arguments)
      elsif @unread_messages.empty?
        # There are no more messages.
        break
      else
        # There are unread messages with unexpected message numbers.
        next_available_number = @unread_messages.min_by(&:number)
        STDERR.puts "scratch_unit_test_translate: warning: " +
          "expected message number #{@next_expected_number}, " +
          "settling for #{next_available_number}"
        # Tolerate this situation by pretending to expect the next available message.
        @next_expected_number = next_available_number
      end
    end
  end
end

# Reads commands from a fifo until the "quit" command arrives.
# The commands can consist of one or more lines.
# The first line must indicate the type of the command.
def main(fifo)
  unless File.exist?(fifo)
    puts "Usage: scratch_unit_test_translate <fifo>"
    puts "Error: file does not exist: \"#{fifo}\""
    exit
  end

  presenter = Presenter.new
  File.open(fifo, "r") do |io|
    message_reader = MessageReader.new(io)
    task, session, client = message_reader.read_message
    unless task == "message_init" && session && client
      throw "Expected message_init <session> <client>, received: #{([task] + arguments).shelljoin}"
    end
    while message_components = message_reader.read_message
      stubbornly do
        task, *arguments = message_components
        case task.chomp
        when "message_assert"
          presenter.present_assertion(Assertion.from_arguments(arguments))
        when "message_context_error"
          suite, context, *message = arguments
          presenter.present_error(NonAssertionError.new(suite, context, message.join(" ")))
        when "message_non_assertion_error"
          suite, *message = arguments
          presenter.present_error(NonAssertionError.new(suite, nil, message.join(" ")))
        when "message_quit"
          presenter.present_summary
          system("echo 'evaluate-commands -client #{client} %(scratch-unit-test-quit)' | kak -p #{session}")
          break
        else
          throw "Unexpected task: #{([task] + arguments).shelljoin}"
        end
      end
    end
  end
end

begin
  main(ARGV.shift)
rescue => e
  puts e.to_s
  puts e.backtrace
end
